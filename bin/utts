#!/usr/bin/env ruby
# frozen_string_literal: true

# utts - Unified Text-to-Speech CLI
# Supports Piper neural TTS, macOS 'say', and Linux espeak-ng
#
# Usage: utts "message" [options]
#
# Options:
#   --engine ENGINE    TTS engine: 'piper', 'say', or 'espeak' (auto-detected)
#   --voice VOICE      Specific voice name (engine-dependent)
#   --agent TYPE       Use agent-specific voice mapping
#   --rate RATE        Speaking rate for 'say' engine (default: 200)
#   --mute             Mute TTS (creates control file)
#   --unmute           Unmute TTS (removes control file)
#   --status           Show mute status
#   --list-voices      List available voices for current engine
#   --list-agents      List agent voice mappings
#   --caller NAME      Caller identifier (project name)
#   --intent TEXT      Session intent (combines with --caller as "caller: intent")
#   --metadata JSON    JSON metadata for notification (including actions)
#   --history [N]      Show last N notifications (default: 10)
#   --replay [ID]      Replay notification (most recent if no ID)
#   --activate [ID]    Trigger action for notification (most recent if no ID)
#   --dismiss [ID]     Dismiss notification (most recent if no ID)
#   --dismiss-all      Dismiss all notifications
#   --notifications    Open notification dashboard (StreamWeaver UI)
#   --silent           Log notification without audio or system notification
#   -h, --help         Show this help
#
# Environment Variables:
#   UTTS_DIR           utts installation path (default: auto-detect from script location)
#   TTS_VOICE          Default voice
#   TTS_RATE           Speaking rate for 'say' (default: 200)
#
# Tiers:
#   1. Minimal: Clone only - uses say (macOS) or espeak (Linux)
#   2. Standard: + Piper - high-quality neural voices
#   3. Premium: + StreamWeaver - interactive setup wizard

require 'optparse'
require 'fileutils'
require 'yaml'
require 'json'

# Resolve script location for UTTS_DIR default
SCRIPT_DIR = File.dirname(File.realpath(__FILE__))
UTTS_DIR = ENV.fetch('UTTS_DIR', File.expand_path('..', SCRIPT_DIR))

# Mute control & config
CONFIG_DIR = File.expand_path('~/.config/utts')
MUTED_FILE = File.join(CONFIG_DIR, 'muted')
VOICE_CONFIG_FILE = File.join(CONFIG_DIR, 'voice-mappings.yaml')

# Configuration
DEFAULT_RATE = ENV.fetch('TTS_RATE', '200')

# Agent voice mappings
AGENT_VOICES = {
  'say' => {
    'default'         => 'Samantha',
    'general-purpose' => 'Alex',
    'explore'         => 'Daniel',
    'researcher'      => 'Karen',
    'engineer'        => 'Fred',
    'architect'       => 'Reed (English (UK))',
    'designer'        => 'Moira',
    'pentester'       => 'Rishi',
    'writer'          => 'Tessa',
    'plan'            => 'Karen',
    'code-reviewer'   => 'Moira',
    'intern'          => 'Tessa'
  },
  'piper' => {
    'default'         => 'en_US-lessac-medium',
    'general-purpose' => 'en_US-ryan-medium',
    'explore'         => 'en_GB-alan-medium',
    'researcher'      => 'en_US-amy-medium',
    'engineer'        => 'en_US-joe-medium',
    'architect'       => 'en_GB-northern_english_male-medium',
    'designer'        => 'en_GB-cori-medium',
    'pentester'       => 'en_US-kusal-medium',
    'writer'          => 'en_GB-alba-medium',
    'plan'            => 'en_US-amy-medium',
    'code-reviewer'   => 'en_GB-cori-medium',
    'intern'          => 'en_US-kristin-medium'
  },
  'espeak' => {
    'default' => 'en'  # Basic espeak, no custom mappings
  }
}.freeze

# Default voices per engine
DEFAULT_VOICES = {
  'say' => 'Samantha',
  'piper' => 'en_US-lessac-medium',
  'espeak' => 'en'
}.freeze

# Load voice mappings from YAML config file (falls back to defaults)
def load_voice_mappings
  return AGENT_VOICES unless File.exist?(VOICE_CONFIG_FILE)

  begin
    loaded = YAML.safe_load(File.read(VOICE_CONFIG_FILE)) || {}
    # Merge with defaults to ensure all keys exist
    result = {}
    AGENT_VOICES.each do |engine, agents|
      result[engine] = agents.dup
      if loaded[engine].is_a?(Hash)
        loaded[engine].each { |agent, voice| result[engine][agent] = voice }
      end
    end
    result
  rescue StandardError
    AGENT_VOICES
  end
end

# --- Engine Detection ---

def piper_available?
  piper_bin = File.join(UTTS_DIR, '.venv', 'bin', 'piper')
  voices_dir = File.join(UTTS_DIR, 'voices')
  File.executable?(piper_bin) && Dir.exist?(voices_dir) && !Dir.glob(File.join(voices_dir, '*.onnx')).empty?
end

def say_available?
  RUBY_PLATFORM.include?('darwin') && File.executable?('/usr/bin/say')
end

def espeak_available?
  system('which espeak-ng > /dev/null 2>&1') || system('which espeak > /dev/null 2>&1')
end

def detect_engine
  return 'piper' if piper_available?
  return 'say' if say_available?
  return 'espeak' if espeak_available?
  nil
end

# --- Mute Control ---

def muted?
  File.exist?(MUTED_FILE)
end

def mute!
  FileUtils.mkdir_p(CONFIG_DIR)
  FileUtils.touch(MUTED_FILE)
  puts "ðŸ”‡ TTS muted"
end

def unmute!
  FileUtils.rm_f(MUTED_FILE)
  puts "ðŸ”Š TTS unmuted"
end

def show_status
  if muted?
    puts "ðŸ”‡ TTS is MUTED"
    puts "   Control file: #{MUTED_FILE}"
    puts "   Run: utts --unmute"
  else
    engine = detect_engine
    puts "ðŸ”Š TTS is ACTIVE"
    puts "   Engine: #{engine || 'none available'}"
    puts "   UTTS_DIR: #{UTTS_DIR}"
    puts "   Run: utts --mute (to silence)"
  end
end

# --- TTS Engines ---

def speak_say(message, voice, rate)
  system('/usr/bin/say', '-v', voice, '-r', rate, message)
end

def speak_piper(message, voice)
  voice_path = File.join(UTTS_DIR, 'voices', "#{voice}.onnx")
  config_path = "#{voice_path}.json"

  unless File.exist?(voice_path)
    warn "Piper voice not found: #{voice_path}"
    warn "Available voices: #{list_piper_voices.join(', ')}"
    exit 1
  end

  # Read sample rate from voice config (default 22050 for medium/high quality)
  sample_rate = 22050
  if File.exist?(config_path)
    begin
      config = JSON.parse(File.read(config_path))
      sample_rate = config.dig('audio', 'sample_rate') || 22050
    rescue StandardError
      # Use default if config can't be read
    end
  end

  piper_bin = File.join(UTTS_DIR, '.venv', 'bin', 'piper')

  # Escape for shell
  escaped_msg = message.gsub("'", "'\\''")
  escaped_piper = piper_bin.gsub("'", "'\\''")
  escaped_voice = voice_path.gsub("'", "'\\''")

  cmd = "echo '#{escaped_msg}' | " \
        "'#{escaped_piper}' " \
        "--model '#{escaped_voice}' " \
        "--output-raw 2>/dev/null | " \
        "play -q -r #{sample_rate} -b 16 -e signed -c 1 -t raw -"

  system(cmd)
end

def speak_espeak(message, voice)
  espeak_cmd = system('which espeak-ng > /dev/null 2>&1') ? 'espeak-ng' : 'espeak'
  system(espeak_cmd, '-v', voice, message)
end

# --- Voice Listing ---

def list_say_voices
  output = `say -v '?'`
  output.lines.map { |line| line.split.first }.sort
end

def list_piper_voices
  voices_dir = File.join(UTTS_DIR, 'voices')
  return [] unless Dir.exist?(voices_dir)

  Dir.glob(File.join(voices_dir, '*.onnx')).map do |f|
    File.basename(f, '.onnx')
  end.sort
end

def list_espeak_voices
  espeak_cmd = system('which espeak-ng > /dev/null 2>&1') ? 'espeak-ng' : 'espeak'
  output = `#{espeak_cmd} --voices 2>/dev/null`
  output.lines.drop(1).map { |line| line.split[4] }.compact.uniq.sort
rescue
  ['en', 'en-us', 'en-gb']
end

def list_voices(engine)
  case engine
  when 'say'
    puts "macOS 'say' voices:"
    list_say_voices.each { |v| puts "  #{v}" }
  when 'piper'
    puts "Piper TTS voices (in #{UTTS_DIR}/voices/):"
    voices = list_piper_voices
    if voices.empty?
      puts "  (none installed - run scripts/setup.sh)"
    else
      voices.each { |v| puts "  #{v}" }
    end
  when 'espeak'
    puts "espeak voices:"
    list_espeak_voices.take(20).each { |v| puts "  #{v}" }
    puts "  ..."
  end
end

def list_agents(engine)
  puts "Agent voice mappings for '#{engine}' engine:"
  mappings = load_voice_mappings
  voices = mappings[engine] || mappings['say']
  voices.each do |agent, voice|
    puts "  #{agent.ljust(16)} => #{voice}"
  end
  if File.exist?(VOICE_CONFIG_FILE)
    puts "\n  (loaded from #{VOICE_CONFIG_FILE})"
  end
end

def sanitize_message(message)
  message.gsub(/[^a-zA-Z0-9\s.,!?'\-]/, '').strip[0, 500]
end

# --- Notification Logging ---

def notifications_available?
  notifications_lib = File.join(UTTS_DIR, 'lib', 'utts', 'notifications.rb')
  File.exist?(notifications_lib)
end

def require_notifications
  notifications_lib = File.join(UTTS_DIR, 'lib', 'utts', 'notifications.rb')
  require notifications_lib
end

def log_notification(message, options, voice, send_system_notification: true)
  return unless notifications_available?

  begin
    require_notifications

    # Combine caller and intent: "project: session intent"
    caller_str = options[:caller]
    if caller_str && options[:intent]
      caller_str = "#{caller_str}: #{options[:intent]}"
    elsif options[:intent]
      caller_str = options[:intent]
    end

    Utts::Notifications.log(
      text: message,
      caller: caller_str,
      agent: options[:agent],
      voice: voice,
      metadata: options[:metadata] || {}
    )

    # Send macOS notification (unless --silent)
    if send_system_notification
      Utts::MacosNotifier.send_notification(
        notification_text: message,
        caller_name: caller_str,
        muted: muted?
      )
    end
  rescue StandardError => e
    warn "Notification logging failed: #{e.message}" if ENV['UTTS_DEBUG']
  end
end

def show_history(limit)
  unless notifications_available?
    warn "Notification history requires Tier 3 (bundle install)"
    exit 1
  end

  require_notifications
  notifications = Utts::Notifications.list(limit: limit, include_dismissed: true)

  if notifications.empty?
    puts "No notifications in history"
    return
  end

  puts "Last #{[limit, notifications.size].min} notifications:\n\n"
  notifications.each do |n|
    time = Time.parse(n.timestamp).localtime.strftime('%b %d %H:%M')
    status = n.dismissed? ? 'âœ“' : 'â—‹'
    caller_str = n.caller ? "  #{n.caller}" : ''
    puts "#{status} [#{n.id}] #{time}#{caller_str}"
    puts "  \"#{n.text}\""
    puts
  end
end

def replay_notification(id_or_latest)
  unless notifications_available?
    warn "Replay requires Tier 3 (bundle install)"
    exit 1
  end

  require_notifications

  if id_or_latest == :latest
    notifications = Utts::Notifications.list(limit: 1)
    if notifications.empty?
      warn "No notifications to replay"
      exit 1
    end
    notification = notifications.first
  else
    notification = Utts::Notifications.find(id_or_latest)
    unless notification
      warn "Notification not found: #{id_or_latest}"
      exit 1
    end
  end

  puts "Replaying: \"#{notification.text}\""
  Utts::Notifications.replay(notification.id)
end

def activate_notification(id_or_latest)
  unless notifications_available?
    warn "Activate requires Tier 3 (bundle install)"
    exit 1
  end

  require_notifications

  if id_or_latest == :latest
    notifications = Utts::Notifications.list(limit: 1)
    if notifications.empty?
      warn "No notifications to activate"
      exit 1
    end
    notification = notifications.first
  else
    notification = Utts::Notifications.find(id_or_latest)
    unless notification
      warn "Notification not found: #{id_or_latest}"
      exit 1
    end
  end

  if notification.metadata.nil? || notification.metadata['action'].nil?
    warn "No action defined for notification: #{notification.id}"
    exit 1
  end

  puts "Activating: #{notification.caller || notification.id}"
  Utts::Notifications.activate(notification.id)
end

def dismiss_notification(id_or_latest)
  unless notifications_available?
    warn "Dismiss requires Tier 3 (bundle install)"
    exit 1
  end

  require_notifications

  if id_or_latest == :latest
    notifications = Utts::Notifications.list(limit: 1)
    if notifications.empty?
      warn "No notifications to dismiss"
      exit 1
    end
    notification = notifications.first
    Utts::Notifications.dismiss(notification.id)
    puts "Dismissed: #{notification.caller || notification.id}"
  else
    result = Utts::Notifications.dismiss(id_or_latest)
    if result
      puts "Dismissed: #{id_or_latest}"
    else
      warn "Notification not found: #{id_or_latest}"
      exit 1
    end
  end
end

def dismiss_all_notifications
  unless notifications_available?
    warn "Dismiss requires Tier 3 (bundle install)"
    exit 1
  end

  require_notifications
  Utts::Notifications.dismiss_all
  puts "All notifications dismissed"
end

def open_notifications_ui
  notifications_ui = File.join(UTTS_DIR, 'scripts', 'notifications.rb')
  unless File.exist?(notifications_ui)
    warn "Notification UI not found. Tier 3 required."
    warn "Expected: #{notifications_ui}"
    exit 1
  end

  # Check for running instance via PID file
  pid_file = File.join(CONFIG_DIR, 'notifications.pid')
  if File.exist?(pid_file)
    pid = File.read(pid_file).strip.to_i
    begin
      Process.kill(0, pid) # Check if process is running
      # Process is running, try to find URL and open browser
      url_file = File.join(CONFIG_DIR, 'notifications.url')
      if File.exist?(url_file)
        url = File.read(url_file).strip
        system('open', url)
        puts "Opened existing notification dashboard: #{url}"
        exit 0
      end
    rescue Errno::ESRCH, Errno::EPERM
      # Process not running, clean up stale PID file
      FileUtils.rm_f(pid_file)
    end
  end

  # Start new instance
  puts "Starting notification dashboard..."
  exec('ruby', notifications_ui)
end

# --- Main ---

options = {
  engine: nil,  # auto-detect
  voice: nil,
  agent: nil,
  rate: DEFAULT_RATE
}

parser = OptionParser.new do |opts|
  opts.banner = "Usage: utts \"message\" [options]"

  opts.on('--engine ENGINE', %w[say piper espeak], "TTS engine (auto-detected)") do |e|
    options[:engine] = e
  end

  opts.on('--voice VOICE', 'Specific voice name') do |v|
    options[:voice] = v
  end

  opts.on('--agent TYPE', 'Use agent-specific voice mapping') do |a|
    options[:agent] = a.downcase
  end

  opts.on('--rate RATE', 'Speaking rate for say engine') do |r|
    options[:rate] = r
  end

  opts.on('--mute', 'Mute TTS') do
    mute!
    exit 0
  end

  opts.on('--unmute', 'Unmute TTS') do
    unmute!
    exit 0
  end

  opts.on('--status', 'Show mute status') do
    show_status
    exit 0
  end

  opts.on('--list-voices', 'List available voices') do
    engine = options[:engine] || detect_engine || 'say'
    list_voices(engine)
    exit 0
  end

  opts.on('--list-agents', 'List agent voice mappings') do
    engine = options[:engine] || detect_engine || 'say'
    list_agents(engine)
    exit 0
  end

  opts.on('--caller CALLER', 'Caller identifier (project name)') do |c|
    options[:caller] = c
  end

  opts.on('--intent INTENT', 'Session intent (combines with --caller as "caller: intent")') do |i|
    options[:intent] = i
  end

  opts.on('--metadata JSON', 'JSON metadata for notification') do |m|
    begin
      options[:metadata] = JSON.parse(m)
    rescue JSON::ParserError
      warn "Invalid JSON for --metadata"
      exit 1
    end
  end

  opts.on('--history [N]', Integer, 'Show last N notifications (default: 10)') do |n|
    options[:history] = n || 10
  end

  opts.on('--replay [ID]', 'Replay notification (most recent if no ID)') do |id|
    options[:replay] = id || :latest
  end

  opts.on('--silent', 'Log notification without audio or system notification') do
    options[:silent] = true
  end

  opts.on('--activate [ID]', 'Trigger action for notification (most recent if no ID)') do |id|
    options[:activate] = id || :latest
  end

  opts.on('--dismiss [ID]', 'Dismiss notification (most recent if no ID)') do |id|
    options[:dismiss] = id || :latest
  end

  opts.on('--dismiss-all', 'Dismiss all notifications') do
    options[:dismiss_all] = true
  end

  opts.on('--notifications', 'Open notification dashboard (StreamWeaver UI)') do
    options[:notifications] = true
  end

  opts.on('-h', '--help', 'Show this help') do
    puts opts
    puts "\nDetected engine: #{detect_engine || 'none'}"
    puts "UTTS_DIR: #{UTTS_DIR}"
    exit 0
  end
end

begin
  parser.parse!
rescue OptionParser::InvalidOption => e
  warn e.message
  warn parser
  exit 1
end

# Handle --history
if options[:history]
  show_history(options[:history])
  exit 0
end

# Handle --replay
if options[:replay]
  replay_notification(options[:replay])
  exit 0
end

# Handle --activate
if options[:activate]
  activate_notification(options[:activate])
  exit 0
end

# Handle --dismiss
if options[:dismiss]
  dismiss_notification(options[:dismiss])
  exit 0
end

# Handle --dismiss-all
if options[:dismiss_all]
  dismiss_all_notifications
  exit 0
end

# Handle --notifications
if options[:notifications]
  open_notifications_ui
  exit 0
end

# Check mute status - but still log if not silent
if muted? && !options[:silent]
  # Log notification even when muted (unless --silent)
  message = ARGV.join(' ')
  unless message.empty?
    safe_message = sanitize_message(message)
    engine = options[:engine] || detect_engine || 'say'
    voice = options[:voice] || DEFAULT_VOICES[engine]
    log_notification(safe_message, options, voice) unless safe_message.empty?
  end
  exit 0
end

# Get message
message = ARGV.join(' ')

if message.empty?
  warn "No message provided"
  warn parser
  exit 1
end

# Sanitize
safe_message = sanitize_message(message)
if safe_message.empty?
  warn "Message contains no speakable content after sanitization"
  exit 1
end

# Detect or use specified engine
engine = options[:engine] || detect_engine

unless engine
  warn "No TTS engine available."
  warn "  macOS: 'say' should be built-in"
  warn "  Linux: install espeak-ng (apt install espeak-ng)"
  warn "  Any: run scripts/setup.sh for Piper neural TTS"
  exit 1
end

# Determine voice
voice = if options[:voice]
          options[:voice]
        elsif options[:agent]
          mappings = load_voice_mappings
          agent_voices = mappings[engine] || mappings['say']
          agent_voices[options[:agent]] || agent_voices['default']
        else
          ENV['TTS_VOICE'] || DEFAULT_VOICES[engine]
        end

# Speak (unless --silent)
unless options[:silent]
  case engine
  when 'say'
    speak_say(safe_message, voice, options[:rate])
  when 'piper'
    speak_piper(safe_message, voice)
  when 'espeak'
    speak_espeak(safe_message, voice)
  end
end

# Log notification (--silent skips macOS notification)
log_notification(safe_message, options, voice, send_system_notification: !options[:silent])

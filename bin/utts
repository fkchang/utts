#!/usr/bin/env ruby
# frozen_string_literal: true

# utts - Unified Text-to-Speech CLI
# Supports Piper neural TTS, macOS 'say', and Linux espeak-ng
#
# Usage: utts "message" [options]
#
# Options:
#   --engine ENGINE    TTS engine: 'piper', 'say', or 'espeak' (auto-detected)
#   --voice VOICE      Specific voice name (engine-dependent)
#   --agent TYPE       Use agent-specific voice mapping
#   --rate RATE        Speaking rate in wpm (default: 200, affects all engines)
#   --pitch PITCH      Pitch 0-99 (default: 45, higher=higher pitch/more expressive)
#   --emotion EMOTION  Emotion for prosody (excited, celebration, success, caution, urgent, question)
#   --list-emotions    List available emotions and their detection patterns
#   --mute             Mute TTS (creates control file)
#   --unmute           Unmute TTS (removes control file)
#   --status           Show mute status
#   --list-voices      List available voices for current engine
#   --list-agents      List agent voice mappings
#   --caller NAME      Caller identifier (project name)
#   --intent TEXT      Session intent (combines with --caller as "caller: intent")
#   --metadata JSON    JSON metadata for notification (including actions)
#   --history [N]      Show last N notifications (default: 10)
#   --replay [ID]      Replay notification (most recent if no ID)
#   --activate [ID]    Trigger action for notification (most recent if no ID)
#   --dismiss [ID]     Dismiss notification (most recent if no ID)
#   --dismiss-all      Dismiss all notifications
#   --notifications    Open notification dashboard (StreamWeaver UI)
#   --silent           Log notification without audio or system notification
#   -h, --help         Show this help
#
# Environment Variables:
#   UTTS_DIR           utts installation path (default: auto-detect from script location)
#   TTS_VOICE          Default voice
#   TTS_RATE           Speaking rate for 'say' (default: 200)
#
# Tiers:
#   1. Minimal: Clone only - uses say (macOS) or espeak (Linux)
#   2. Standard: + Piper - high-quality neural voices
#   3. Premium: + StreamWeaver - interactive setup wizard

require 'optparse'
require 'fileutils'
require 'yaml'
require 'json'

# Resolve script location for UTTS_DIR default
SCRIPT_DIR = File.dirname(File.realpath(__FILE__))
UTTS_DIR = ENV.fetch('UTTS_DIR', File.expand_path('..', SCRIPT_DIR))

# Mute control & config
CONFIG_DIR = File.expand_path('~/.config/utts')
MUTED_FILE = File.join(CONFIG_DIR, 'muted')
VOICE_CONFIG_FILE = File.join(CONFIG_DIR, 'voice-mappings.yaml')

# Configuration
DEFAULT_RATE = ENV.fetch('TTS_RATE', '200')
DEFAULT_PITCH = ENV.fetch('TTS_PITCH', '45')  # 0-99 for say, mapped for others

# Prosody defaults per engine
# say: rate=wpm, pitch=pbas (0-99, 45=normal), pmod=pitch modulation (0-127, 60=normal)
# piper: length_scale (1.0=normal, <1=faster), noise_scale (0.667=normal, higher=more expressive)
# espeak: rate=wpm (175=normal), pitch=0-99 (50=normal)
PROSODY_DEFAULTS = {
  'say' => { rate: 200, pitch: 45, pmod: 60 },
  'piper' => { length_scale: 1.0, noise_scale: 0.667 },
  'espeak' => { rate: 175, pitch: 50 }
}.freeze

# Emotion detection patterns (from pai-voice-system prosody-enhancer)
# Used for auto-detecting emotional tone and applying appropriate prosody
EMOTION_PATTERNS = {
  excited: [
    /\b(breakthrough|discovered|found it|eureka|amazing|incredible|wow)\b/i,
    /!{2,}|ðŸ’¥|ðŸ”¥|âš¡/
  ],
  celebration: [
    /\b(finally|at last|we did it|victory|hooray|woohoo)\b/i,
    /\b(all .* passing|zero errors|tests? pass)\b/i,
    /ðŸŽ‰|ðŸ¥³|ðŸŽŠ/
  ],
  success: [
    /\b(completed|finished|done|fixed|resolved|ready|working)\b/i,
    /âœ…|âœ¨|ðŸ‘/
  ],
  caution: [
    /\b(warning|careful|partial|incomplete|issue|problem)\b/i,
    /âš ï¸|ðŸŸ¡/
  ],
  urgent: [
    /\b(urgent|critical|failing|broken|alert|error|failed)\b/i,
    /ðŸš¨|âŒ|ðŸ”´/
  ],
  question: [
    /\b(needs? input|waiting|question|help|stuck)\b/i,
    /\?{2,}|ðŸ¤”|â“/
  ]
}.freeze

# Prosody settings per emotion per engine
# Emotion affects rate, pitch (pbas), and pitch modulation (pmod)
EMOTION_PROSODY = {
  excited: {
    'say' => { rate: 240, pitch: 50, pmod: 100 },
    'piper' => { length_scale: 0.85, noise_scale: 0.8 },
    'espeak' => { rate: 210, pitch: 60 }
  },
  celebration: {
    'say' => { rate: 220, pitch: 48, pmod: 90 },
    'piper' => { length_scale: 0.9, noise_scale: 0.75 },
    'espeak' => { rate: 200, pitch: 55 }
  },
  success: {
    'say' => { rate: 200, pitch: 45, pmod: 70 },
    'piper' => { length_scale: 1.0, noise_scale: 0.7 },
    'espeak' => { rate: 180, pitch: 50 }
  },
  caution: {
    'say' => { rate: 170, pitch: 38, pmod: 40 },
    'piper' => { length_scale: 1.15, noise_scale: 0.5 },
    'espeak' => { rate: 150, pitch: 40 }
  },
  urgent: {
    'say' => { rate: 260, pitch: 55, pmod: 110 },
    'piper' => { length_scale: 0.75, noise_scale: 0.9 },
    'espeak' => { rate: 220, pitch: 70 }
  },
  question: {
    'say' => { rate: 190, pitch: 47, pmod: 75 },
    'piper' => { length_scale: 1.05, noise_scale: 0.7 },
    'espeak' => { rate: 170, pitch: 52 }
  },
  neutral: {
    'say' => { rate: 200, pitch: 42, pmod: 60 },
    'piper' => { length_scale: 1.0, noise_scale: 0.667 },
    'espeak' => { rate: 175, pitch: 50 }
  }
}.freeze

# Agent voice mappings
AGENT_VOICES = {
  'say' => {
    'default'         => 'Samantha',
    'general-purpose' => 'Alex',
    'explore'         => 'Daniel',
    'researcher'      => 'Karen',
    'engineer'        => 'Fred',
    'architect'       => 'Reed (English (UK))',
    'designer'        => 'Moira',
    'pentester'       => 'Rishi',
    'writer'          => 'Tessa',
    'plan'            => 'Karen',
    'code-reviewer'   => 'Moira',
    'intern'          => 'Tessa'
  },
  'piper' => {
    'default'         => 'en_US-lessac-medium',
    'general-purpose' => 'en_US-ryan-medium',
    'explore'         => 'en_GB-alan-medium',
    'researcher'      => 'en_US-amy-medium',
    'engineer'        => 'en_US-joe-medium',
    'architect'       => 'en_GB-northern_english_male-medium',
    'designer'        => 'en_GB-cori-medium',
    'pentester'       => 'en_US-kusal-medium',
    'writer'          => 'en_GB-alba-medium',
    'plan'            => 'en_US-amy-medium',
    'code-reviewer'   => 'en_GB-cori-medium',
    'intern'          => 'en_US-kristin-medium'
  },
  'espeak' => {
    'default' => 'en'  # Basic espeak, no custom mappings
  }
}.freeze

# Default voices per engine
DEFAULT_VOICES = {
  'say' => 'Samantha',
  'piper' => 'en_US-lessac-medium',
  'espeak' => 'en'
}.freeze

# Load voice mappings from YAML config file (falls back to defaults)
def load_voice_mappings
  return AGENT_VOICES unless File.exist?(VOICE_CONFIG_FILE)

  begin
    loaded = YAML.safe_load(File.read(VOICE_CONFIG_FILE)) || {}
    # Merge with defaults to ensure all keys exist
    result = {}
    AGENT_VOICES.each do |engine, agents|
      result[engine] = agents.dup
      if loaded[engine].is_a?(Hash)
        loaded[engine].each { |agent, voice| result[engine][agent] = voice }
      end
    end
    result
  rescue StandardError
    AGENT_VOICES
  end
end

# --- Engine Detection ---

def piper_available?
  piper_bin = File.join(UTTS_DIR, '.venv', 'bin', 'piper')
  voices_dir = File.join(UTTS_DIR, 'voices')
  File.executable?(piper_bin) && Dir.exist?(voices_dir) && !Dir.glob(File.join(voices_dir, '*.onnx')).empty?
end

def say_available?
  RUBY_PLATFORM.include?('darwin') && File.executable?('/usr/bin/say')
end

def espeak_available?
  system('which espeak-ng > /dev/null 2>&1') || system('which espeak > /dev/null 2>&1')
end

def detect_engine
  return 'piper' if piper_available?
  return 'say' if say_available?
  return 'espeak' if espeak_available?
  nil
end

# --- Mute Control ---

def muted?
  File.exist?(MUTED_FILE)
end

def mute!
  FileUtils.mkdir_p(CONFIG_DIR)
  FileUtils.touch(MUTED_FILE)
  puts "ðŸ”‡ TTS muted"
end

def unmute!
  FileUtils.rm_f(MUTED_FILE)
  puts "ðŸ”Š TTS unmuted"
end

def show_status
  if muted?
    puts "ðŸ”‡ TTS is MUTED"
    puts "   Control file: #{MUTED_FILE}"
    puts "   Run: utts --unmute"
  else
    engine = detect_engine
    puts "ðŸ”Š TTS is ACTIVE"
    puts "   Engine: #{engine || 'none available'}"
    puts "   UTTS_DIR: #{UTTS_DIR}"
    puts "   Run: utts --mute (to silence)"
  end
end

# --- TTS Engines ---

def speak_say(message, voice, rate, pitch = nil)
  # Use embedded prosody commands for pitch control
  # [[rate N]] = words per minute
  # [[pbas N]] = pitch base (0-99, 45=normal)
  # [[pmod N]] = pitch modulation/range (0-127, 60=normal)
  if pitch
    pitch_val = pitch.to_i.clamp(0, 99)
    # Higher pitch also benefits from slightly higher modulation
    pmod = (60 + (pitch_val - 45) * 0.5).clamp(30, 100).to_i
    prosody_prefix = "[[pbas #{pitch_val}; pmod #{pmod}]]"
    message = "#{prosody_prefix} #{message}"
  end
  system('/usr/bin/say', '-v', voice, '-r', rate.to_s, message)
end

def speak_piper(message, voice, rate = nil, pitch = nil, emotion_prosody = nil)
  voice_path = File.join(UTTS_DIR, 'voices', "#{voice}.onnx")
  config_path = "#{voice_path}.json"

  unless File.exist?(voice_path)
    warn "Piper voice not found: #{voice_path}"
    warn "Available voices: #{list_piper_voices.join(', ')}"
    exit 1
  end

  # Read sample rate from voice config (default 22050 for medium/high quality)
  sample_rate = 22050
  if File.exist?(config_path)
    begin
      config = JSON.parse(File.read(config_path))
      sample_rate = config.dig('audio', 'sample_rate') || 22050
    rescue StandardError
      # Use default if config can't be read
    end
  end

  piper_bin = File.join(UTTS_DIR, '.venv', 'bin', 'piper')

  # Determine length_scale and noise_scale
  # Priority: CLI flags > emotion_prosody > defaults
  if emotion_prosody && emotion_prosody[:length_scale]
    # Use emotion-based prosody directly
    length_scale = emotion_prosody[:length_scale]
    noise_scale = emotion_prosody[:noise_scale] || 0.667
    # CLI rate/pitch can still override
    if rate
      base_rate = 200.0
      length_scale = (base_rate / rate.to_f).clamp(0.5, 2.0)
    end
    if pitch
      pitch_val = pitch.to_i
      noise_scale = (0.4 + (pitch_val / 99.0) * 0.5).clamp(0.3, 1.0)
    end
  else
    # Calculate from rate/pitch (Phase 1 behavior)
    length_scale = if rate
                     base_rate = 200.0
                     (base_rate / rate.to_f).clamp(0.5, 2.0)
                   else
                     1.0
                   end

    noise_scale = if pitch
                    pitch_val = pitch.to_i
                    (0.4 + (pitch_val / 99.0) * 0.5).clamp(0.3, 1.0)
                  else
                    0.667
                  end
  end

  # Escape for shell
  escaped_msg = message.gsub("'", "'\\''")
  escaped_piper = piper_bin.gsub("'", "'\\''")
  escaped_voice = voice_path.gsub("'", "'\\''")

  cmd = "echo '#{escaped_msg}' | " \
        "'#{escaped_piper}' " \
        "--model '#{escaped_voice}' " \
        "--length-scale #{length_scale} " \
        "--noise-scale #{noise_scale} " \
        "--output-raw 2>/dev/null | " \
        "play -q -r #{sample_rate} -b 16 -e signed -c 1 -t raw -"

  system(cmd)
end

def speak_espeak(message, voice, rate = nil, pitch = nil)
  espeak_cmd = system('which espeak-ng > /dev/null 2>&1') ? 'espeak-ng' : 'espeak'

  args = [espeak_cmd, '-v', voice]

  # espeak rate: -s WPM (default 175)
  if rate
    args += ['-s', rate.to_s]
  end

  # espeak pitch: -p 0-99 (default 50)
  if pitch
    args += ['-p', pitch.to_i.clamp(0, 99).to_s]
  end

  args << message
  system(*args)
end

# --- Voice Listing ---

def list_say_voices
  output = `say -v '?'`
  output.lines.map { |line| line.split.first }.sort
end

def list_piper_voices
  voices_dir = File.join(UTTS_DIR, 'voices')
  return [] unless Dir.exist?(voices_dir)

  Dir.glob(File.join(voices_dir, '*.onnx')).map do |f|
    File.basename(f, '.onnx')
  end.sort
end

def list_espeak_voices
  espeak_cmd = system('which espeak-ng > /dev/null 2>&1') ? 'espeak-ng' : 'espeak'
  output = `#{espeak_cmd} --voices 2>/dev/null`
  output.lines.drop(1).map { |line| line.split[4] }.compact.uniq.sort
rescue
  ['en', 'en-us', 'en-gb']
end

def list_voices(engine)
  case engine
  when 'say'
    puts "macOS 'say' voices:"
    list_say_voices.each { |v| puts "  #{v}" }
  when 'piper'
    puts "Piper TTS voices (in #{UTTS_DIR}/voices/):"
    voices = list_piper_voices
    if voices.empty?
      puts "  (none installed - run scripts/setup.sh)"
    else
      voices.each { |v| puts "  #{v}" }
    end
  when 'espeak'
    puts "espeak voices:"
    list_espeak_voices.take(20).each { |v| puts "  #{v}" }
    puts "  ..."
  end
end

def list_agents(engine)
  puts "Agent voice mappings for '#{engine}' engine:"
  mappings = load_voice_mappings
  voices = mappings[engine] || mappings['say']
  voices.each do |agent, voice|
    puts "  #{agent.ljust(16)} => #{voice}"
  end
  if File.exist?(VOICE_CONFIG_FILE)
    puts "\n  (loaded from #{VOICE_CONFIG_FILE})"
  end
end

# --- Emotion Detection ---

def detect_emotion(message)
  EMOTION_PATTERNS.each do |emotion, patterns|
    patterns.each do |pattern|
      return emotion if pattern.match?(message)
    end
  end
  :neutral
end

def list_emotions
  puts "Available emotions and their triggers:\n\n"
  EMOTION_PATTERNS.each do |emotion, patterns|
    puts "  #{emotion}:"
    patterns.each do |pattern|
      # Show a readable version of the pattern
      puts "    #{pattern.source}"
    end
    puts
  end
  puts "  neutral: (default when no patterns match)"
end

def get_emotion_prosody(emotion, engine)
  settings = EMOTION_PROSODY.dig(emotion, engine) || EMOTION_PROSODY.dig(:neutral, engine)
  settings || {}
end

def sanitize_message(message)
  message.gsub(/[^a-zA-Z0-9\s.,!?'\-]/, '').strip[0, 500]
end

# --- Notification Logging ---

def notifications_available?
  notifications_lib = File.join(UTTS_DIR, 'lib', 'utts', 'notifications.rb')
  File.exist?(notifications_lib)
end

def require_notifications
  notifications_lib = File.join(UTTS_DIR, 'lib', 'utts', 'notifications.rb')
  require notifications_lib
end

def log_notification(message, options, voice, send_system_notification: true)
  return unless notifications_available?

  begin
    require_notifications

    # Combine caller and intent: "project: session intent"
    caller_str = options[:caller]
    if caller_str && options[:intent]
      caller_str = "#{caller_str}: #{options[:intent]}"
    elsif options[:intent]
      caller_str = options[:intent]
    end

    Utts::Notifications.log(
      text: message,
      caller: caller_str,
      agent: options[:agent],
      voice: voice,
      metadata: options[:metadata] || {}
    )

    # Send macOS notification (unless --silent)
    if send_system_notification
      Utts::MacosNotifier.send_notification(
        notification_text: message,
        caller_name: caller_str,
        muted: muted?
      )
    end
  rescue StandardError => e
    warn "Notification logging failed: #{e.message}" if ENV['UTTS_DEBUG']
  end
end

def show_history(limit)
  unless notifications_available?
    warn "Notification history requires Tier 3 (bundle install)"
    exit 1
  end

  require_notifications
  notifications = Utts::Notifications.list(limit: limit, include_dismissed: true)

  if notifications.empty?
    puts "No notifications in history"
    return
  end

  puts "Last #{[limit, notifications.size].min} notifications:\n\n"
  notifications.each do |n|
    time = Time.parse(n.timestamp).localtime.strftime('%b %d %H:%M')
    status = n.dismissed? ? 'âœ“' : 'â—‹'
    caller_str = n.caller ? "  #{n.caller}" : ''
    puts "#{status} [#{n.id}] #{time}#{caller_str}"
    puts "  \"#{n.text}\""
    puts
  end
end

def replay_notification(id_or_latest)
  unless notifications_available?
    warn "Replay requires Tier 3 (bundle install)"
    exit 1
  end

  require_notifications

  if id_or_latest == :latest
    notifications = Utts::Notifications.list(limit: 1)
    if notifications.empty?
      warn "No notifications to replay"
      exit 1
    end
    notification = notifications.first
  else
    notification = Utts::Notifications.find(id_or_latest)
    unless notification
      warn "Notification not found: #{id_or_latest}"
      exit 1
    end
  end

  puts "Replaying: \"#{notification.text}\""
  Utts::Notifications.replay(notification.id)
end

def activate_notification(id_or_latest)
  unless notifications_available?
    warn "Activate requires Tier 3 (bundle install)"
    exit 1
  end

  require_notifications

  if id_or_latest == :latest
    notifications = Utts::Notifications.list(limit: 1)
    if notifications.empty?
      warn "No notifications to activate"
      exit 1
    end
    notification = notifications.first
  else
    notification = Utts::Notifications.find(id_or_latest)
    unless notification
      warn "Notification not found: #{id_or_latest}"
      exit 1
    end
  end

  if notification.metadata.nil? || notification.metadata['action'].nil?
    warn "No action defined for notification: #{notification.id}"
    exit 1
  end

  puts "Activating: #{notification.caller || notification.id}"
  Utts::Notifications.activate(notification.id)
end

def dismiss_notification(id_or_latest)
  unless notifications_available?
    warn "Dismiss requires Tier 3 (bundle install)"
    exit 1
  end

  require_notifications

  if id_or_latest == :latest
    notifications = Utts::Notifications.list(limit: 1)
    if notifications.empty?
      warn "No notifications to dismiss"
      exit 1
    end
    notification = notifications.first
    Utts::Notifications.dismiss(notification.id)
    puts "Dismissed: #{notification.caller || notification.id}"
  else
    result = Utts::Notifications.dismiss(id_or_latest)
    if result
      puts "Dismissed: #{id_or_latest}"
    else
      warn "Notification not found: #{id_or_latest}"
      exit 1
    end
  end
end

def dismiss_all_notifications
  unless notifications_available?
    warn "Dismiss requires Tier 3 (bundle install)"
    exit 1
  end

  require_notifications
  Utts::Notifications.dismiss_all
  puts "All notifications dismissed"
end

def open_notifications_ui
  notifications_ui = File.join(UTTS_DIR, 'scripts', 'notifications.rb')
  unless File.exist?(notifications_ui)
    warn "Notification UI not found. Tier 3 required."
    warn "Expected: #{notifications_ui}"
    exit 1
  end

  # Check for running instance via PID file
  pid_file = File.join(CONFIG_DIR, 'notifications.pid')
  if File.exist?(pid_file)
    pid = File.read(pid_file).strip.to_i
    begin
      Process.kill(0, pid) # Check if process is running
      # Process is running, try to find URL and open browser
      url_file = File.join(CONFIG_DIR, 'notifications.url')
      if File.exist?(url_file)
        url = File.read(url_file).strip
        system('open', url)
        puts "Opened existing notification dashboard: #{url}"
        exit 0
      end
    rescue Errno::ESRCH, Errno::EPERM
      # Process not running, clean up stale PID file
      FileUtils.rm_f(pid_file)
    end
  end

  # Start new instance
  puts "Starting notification dashboard..."
  exec('ruby', notifications_ui)
end

# --- Main ---

options = {
  engine: nil,  # auto-detect
  voice: nil,
  agent: nil,
  rate: DEFAULT_RATE
}

parser = OptionParser.new do |opts|
  opts.banner = "Usage: utts \"message\" [options]"

  opts.on('--engine ENGINE', %w[say piper espeak], "TTS engine (auto-detected)") do |e|
    options[:engine] = e
  end

  opts.on('--voice VOICE', 'Specific voice name') do |v|
    options[:voice] = v
  end

  opts.on('--agent TYPE', 'Use agent-specific voice mapping') do |a|
    options[:agent] = a.downcase
  end

  opts.on('--rate RATE', 'Speaking rate (wpm for say/espeak, affects speed for piper)') do |r|
    options[:rate] = r
  end

  opts.on('--pitch PITCH', 'Pitch (0-99, 45=normal for say, affects expressiveness for piper)') do |p|
    options[:pitch] = p
  end

  opts.on('--emotion EMOTION', 'Emotion for prosody (auto-detected from message if not specified)') do |e|
    options[:emotion] = e.downcase.to_sym
  end

  opts.on('--list-emotions', 'List available emotions and their triggers') do
    list_emotions
    exit 0
  end

  opts.on('--mute', 'Mute TTS') do
    mute!
    exit 0
  end

  opts.on('--unmute', 'Unmute TTS') do
    unmute!
    exit 0
  end

  opts.on('--status', 'Show mute status') do
    show_status
    exit 0
  end

  opts.on('--list-voices', 'List available voices') do
    engine = options[:engine] || detect_engine || 'say'
    list_voices(engine)
    exit 0
  end

  opts.on('--list-agents', 'List agent voice mappings') do
    engine = options[:engine] || detect_engine || 'say'
    list_agents(engine)
    exit 0
  end

  opts.on('--caller CALLER', 'Caller identifier (project name)') do |c|
    options[:caller] = c
  end

  opts.on('--intent INTENT', 'Session intent (combines with --caller as "caller: intent")') do |i|
    options[:intent] = i
  end

  opts.on('--metadata JSON', 'JSON metadata for notification') do |m|
    begin
      options[:metadata] = JSON.parse(m)
    rescue JSON::ParserError
      warn "Invalid JSON for --metadata"
      exit 1
    end
  end

  opts.on('--history [N]', Integer, 'Show last N notifications (default: 10)') do |n|
    options[:history] = n || 10
  end

  opts.on('--replay [ID]', 'Replay notification (most recent if no ID)') do |id|
    options[:replay] = id || :latest
  end

  opts.on('--silent', 'Log notification without audio or system notification') do
    options[:silent] = true
  end

  opts.on('--activate [ID]', 'Trigger action for notification (most recent if no ID)') do |id|
    options[:activate] = id || :latest
  end

  opts.on('--dismiss [ID]', 'Dismiss notification (most recent if no ID)') do |id|
    options[:dismiss] = id || :latest
  end

  opts.on('--dismiss-all', 'Dismiss all notifications') do
    options[:dismiss_all] = true
  end

  opts.on('--notifications', 'Open notification dashboard (StreamWeaver UI)') do
    options[:notifications] = true
  end

  opts.on('-h', '--help', 'Show this help') do
    puts opts
    puts "\nDetected engine: #{detect_engine || 'none'}"
    puts "UTTS_DIR: #{UTTS_DIR}"
    exit 0
  end
end

begin
  parser.parse!
rescue OptionParser::InvalidOption => e
  warn e.message
  warn parser
  exit 1
end

# Handle --history
if options[:history]
  show_history(options[:history])
  exit 0
end

# Handle --replay
if options[:replay]
  replay_notification(options[:replay])
  exit 0
end

# Handle --activate
if options[:activate]
  activate_notification(options[:activate])
  exit 0
end

# Handle --dismiss
if options[:dismiss]
  dismiss_notification(options[:dismiss])
  exit 0
end

# Handle --dismiss-all
if options[:dismiss_all]
  dismiss_all_notifications
  exit 0
end

# Handle --notifications
if options[:notifications]
  open_notifications_ui
  exit 0
end

# Check mute status - but still log if not silent
if muted? && !options[:silent]
  # Log notification even when muted (unless --silent)
  message = ARGV.join(' ')
  unless message.empty?
    safe_message = sanitize_message(message)
    engine = options[:engine] || detect_engine || 'say'
    voice = options[:voice] || DEFAULT_VOICES[engine]
    log_notification(safe_message, options, voice) unless safe_message.empty?
  end
  exit 0
end

# Get message
message = ARGV.join(' ')

if message.empty?
  warn "No message provided"
  warn parser
  exit 1
end

# Sanitize
safe_message = sanitize_message(message)
if safe_message.empty?
  warn "Message contains no speakable content after sanitization"
  exit 1
end

# Detect or use specified engine
engine = options[:engine] || detect_engine

unless engine
  warn "No TTS engine available."
  warn "  macOS: 'say' should be built-in"
  warn "  Linux: install espeak-ng (apt install espeak-ng)"
  warn "  Any: run scripts/setup.sh for Piper neural TTS"
  exit 1
end

# Determine voice
voice = if options[:voice]
          options[:voice]
        elsif options[:agent]
          mappings = load_voice_mappings
          agent_voices = mappings[engine] || mappings['say']
          agent_voices[options[:agent]] || agent_voices['default']
        else
          ENV['TTS_VOICE'] || DEFAULT_VOICES[engine]
        end

# Detect emotion (from original message, not sanitized)
# Use explicit --emotion if provided, otherwise auto-detect
emotion = options[:emotion] || detect_emotion(message)

# Get emotion-based prosody settings
emotion_prosody = get_emotion_prosody(emotion, engine)

# Determine final prosody settings
# For say/espeak: use rate (wpm) and pitch (0-99)
# For piper: use length_scale and noise_scale from emotion_prosody
if engine == 'piper'
  # For piper, use emotion prosody directly (length_scale, noise_scale)
  # CLI flags override emotion prosody if specified
  final_rate = options[:rate] if options[:rate] && options[:rate] != DEFAULT_RATE
  final_pitch = options[:pitch]
  # Pass emotion prosody to piper for length_scale/noise_scale
  piper_prosody = emotion_prosody
else
  # For say/espeak: use rate and pitch
  final_rate = if options[:rate] && options[:rate] != DEFAULT_RATE
                 options[:rate]
               elsif emotion_prosody[:rate]
                 emotion_prosody[:rate]
               else
                 options[:rate]
               end

  final_pitch = if options[:pitch]
                  options[:pitch]
                elsif emotion_prosody[:pitch]
                  emotion_prosody[:pitch]
                else
                  nil
                end
end

# Debug output if UTTS_DEBUG is set
if ENV['UTTS_DEBUG']
  if engine == 'piper'
    warn "Emotion: #{emotion} | Engine: piper | length_scale: #{piper_prosody[:length_scale]} | noise_scale: #{piper_prosody[:noise_scale]}"
  else
    warn "Emotion: #{emotion} | Engine: #{engine} | Rate: #{final_rate} | Pitch: #{final_pitch || 'default'}"
  end
end

# Speak (unless --silent)
unless options[:silent]
  case engine
  when 'say'
    speak_say(safe_message, voice, final_rate, final_pitch)
  when 'piper'
    speak_piper(safe_message, voice, final_rate, final_pitch, piper_prosody)
  when 'espeak'
    speak_espeak(safe_message, voice, final_rate, final_pitch)
  end
end

# Log notification (--silent skips macOS notification)
log_notification(safe_message, options, voice, send_system_notification: !options[:silent])
